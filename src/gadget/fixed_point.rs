use std::ops::Sub;

use halo2_base::{
    utils::{ScalarField, BigPrimeField}, gates::{GateChip, GateInstructions, RangeChip, range::RangeStrategy, RangeInstructions},
    QuantumCell, Context, AssignedValue
};
use halo2_base::QuantumCell::{Constant, Existing, Witness};
use num_bigint::BigUint;
use bitvec::{order::Lsb0, vec::BitVec};

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum FixedPointStrategy {
    Vertical, // vanilla implementation with vertical basic gate(s)
}

/// `PRECISION_BITS` indicates the precision of integer and fractional parts.
/// For example, `PRECISION_BITS = 32` indicates this chip implements 32.32 fixed point decimal arithmetics.
/// The valid range of the fixed point decimal is -max_value < x < max_value.
#[derive(Clone, Debug)]
pub struct FixedPointChip<F: ScalarField, const PRECISION_BITS: u32> {
    strategy: FixedPointStrategy,
    pub gate: RangeChip<F>,
    pub quantization_scale: F,
    pub max_value: F,
    pub min_value: F,
    pub bn254_max: F,
    pub negative_point: F,
    pub lookup_bits: usize,
}

pub fn u128_to_scalar<F: ScalarField>(x: u128) -> F {
    let x_biguint = BigUint::from(x);
    biguint_to_scalar(x_biguint)
}

pub fn biguint_to_scalar<F: ScalarField>(x: BigUint) -> F {
    let x_biguint = x.to_bytes_le();
    let mut x_bytes_le = [0u8; 64];
    for (idx, val) in x_biguint.iter().enumerate() {
        x_bytes_le[idx] = *val;
    }
    let x_f = F::from_bytes_wide(&x_bytes_le);

    x_f
}

impl<F: ScalarField, const PRECISION_BITS: u32> FixedPointChip<F, PRECISION_BITS> {
    pub fn new(strategy: FixedPointStrategy, lookup_bits: usize) -> Self {
        assert!(PRECISION_BITS <= 63, "support only precision bits <= 63");
        assert!(PRECISION_BITS >= 8, "support only precision bits >= 8");
        let gate = RangeChip::new(
            match strategy {
                FixedPointStrategy::Vertical => RangeStrategy::Vertical,
            },
            lookup_bits
        );
        // Simple uniform symmetric quantization scheme which enforces zero point to be exactly 0
        // to reduce lots of computations.
        // Quantization: x_q = xS where S is `quantization_scale`
        // De-quantization: x = x_q / S
        let quantization_scale = u128_to_scalar(2u128.pow(PRECISION_BITS as u32));
        // Becuase BN254 is cyclic, negative number will be denoted as (-x) % m = m - x where m = 2^254,
        // in this chip, we treat all x > negative_point as a negative numbers.
        let bn254_max = biguint_to_scalar(BigUint::from(2u32).pow(254u32).sub(1u32));
        // -max_value % m = negative_point
        let negative_point = bn254_max - u128_to_scalar::<F>(2u128.pow(PRECISION_BITS * 2 + 1)) + F::one();
        // min_value < x < max_value
        let max_value = u128_to_scalar(2u128.pow(PRECISION_BITS*2));
        let min_value = biguint_to_scalar(BigUint::from(2u32).pow(254u32).sub(
            BigUint::from(2u128.pow(PRECISION_BITS*2))));

        Self { strategy, gate, quantization_scale, max_value, min_value, bn254_max, negative_point, lookup_bits }
    }

    pub fn default(lookup_bits: usize) -> Self {
        Self::new(FixedPointStrategy::Vertical, lookup_bits)
    }

    pub fn quantization(&self, x: f64) -> F {
        let sign = x.signum();
        let x = x.abs();
        let x_q = (x * self.quantization_scale.get_lower_128() as f64).round() as u128;
        let x_q_biguint = BigUint::from(x_q).to_bytes_le();
        let mut x_q_bytes_le = [0u8; 64];
        for (idx, val) in x_q_biguint.iter().enumerate() {
            x_q_bytes_le[idx] = *val;
        }
        let mut x_q_f = F::from_bytes_wide(&x_q_bytes_le);
        if sign < 0.0 {
            x_q_f = self.bn254_max - x_q_f;
        }

        x_q_f
    }

    pub fn dequantization(&self, x: F) -> f64 {
        let mut x_mut = x;
        let negative = if x > self.negative_point {
            x_mut = x - self.negative_point + F::one();
            -1f64
        } else {
            1f64
        };
        let x_u128: u128 = x_mut.get_lower_128();
        let quantization_scale = self.quantization_scale.get_lower_128();
        let x_int = (x_u128 / quantization_scale) as f64;
        let x_frac = (x_u128 % quantization_scale) as f64 / quantization_scale as f64;
        let x_deq = negative * (x_int + x_frac);

        x_deq
    }

    fn generate_exp_poly(&self) -> Vec<F> {
        // generated by remez algorithm, poly degree 12, precision bits: 64.28
        let coef: Vec<F> = [
            3.6240421303547230336183979205877e-11, 4.1284327467833130245549169910389e-10,
            0.0000000071086385644026346316624185550542, 0.00000010172297085296590958930245291448,
            0.0000013215904023658396206789543841996, 0.000015252713316417140696221389106544,
            0.00015403531076657894204857389177279, 0.0013333558131297097698435464957392,
            0.0096181291078409107025643582456283, 0.055504108664804181586140094858174,
            0.24022650695910142332414229540187, 0.69314718055994529934452147700678,
            1.0
        ].into_iter().map(|c| self.quantization(c)).collect();

        coef
    }
}

pub trait FixedPointInstructions<F: ScalarField, const PRECISION_BITS: u32> {
    /// Fixed point decimal and its arithmetic functions.
    /// [ref] https://github.com/XMunkki/FixPointCS/blob/c701f57c3cfe6478d1f6fd7578ae040c59386b3d/Cpp/Fixed64.h
    /// [ref] https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol
    ///
    type Gate: GateInstructions<F>;
    type RangeGate: RangeInstructions<F>;

    fn gate(&self) -> &Self::Gate;
    fn range_gate(&self) -> &Self::RangeGate;
    fn strategy(&self) -> FixedPointStrategy;

    fn qabs(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn is_neg(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn sign(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    /// clip the value to ensure it's in the valid range: (-2^p, 2^p), i.e., simulate overflow
    /// Warning: assuome a < 2^{p+1},This may fail silently if a is too large
    /// (e.g., mul of two large number leads to 2^{2p}).
    fn clip(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn polynomial<QA>(
        &self,
        ctx: &mut Context<F>,
        x: impl Into<QuantumCell<F>>,
        coef: impl IntoIterator<Item = QA>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField, QA: Into<QuantumCell<F>>;

    fn qadd(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let res = self.gate().add(ctx, a, b);

        res
    }

    fn qsub(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let res = self.gate().sub(ctx, a, b);

        res
    }
    
    fn qmul(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;
    
    fn qdiv(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn qmod(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    /// exp2
    fn qexp2(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    /// log
    // fn qlog(
    //     &self,
    //     ctx: &mut Context<F>,
    //     a: impl Into<QuantumCell<F>>
    // ) -> AssignedValue<F>
    // where 
    //     F: BigPrimeField;
    
    /// sin
    // fn qsin(
    //     &self,
    //     ctx: &mut Context<F>,
    //     a: impl Into<QuantumCell<F>>
    // ) -> AssignedValue<F>
    // where 
    //     F: BigPrimeField;

    fn check_power_of_two(&self, ctx: &mut Context<F>, pow2_exponent: AssignedValue<F>, exponent: AssignedValue<F>)
    where
        F: BigPrimeField;
}

impl<F: ScalarField, const PRECISION_BITS: u32> FixedPointInstructions<F, PRECISION_BITS> for FixedPointChip<F, PRECISION_BITS> {
    type Gate = GateChip<F>;
    type RangeGate = RangeChip<F>;

    fn range_gate(&self) -> &Self::RangeGate {
        &self.gate
    }

    fn gate(&self) -> &Self::Gate {
        &self.gate.gate()
    }

    fn strategy(&self) -> FixedPointStrategy {
        self.strategy
    }

    fn qabs(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let a_reverse = self.gate().sub(ctx, Constant(self.bn254_max), a);
        let is_neg = self.is_neg(ctx, a);
        let a_abs = self.gate().select(ctx, a_reverse, a, is_neg);

        a_abs
    }

    fn is_neg(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let a_assigned = self.gate().add(ctx, a, Constant(F::zero()));
        let a_bits = self.gate().num_to_bits(ctx, a_assigned, 254);
        // for example, PRECISION_BITS = 63, then neg_point_bits = 1..10..0 where has 127 ones and 217 zeros
        let neg_point_bits: Vec<QuantumCell<F>> = BitVec::<_, Lsb0>::from_vec(
            (BigUint::from(2u32).pow(254u32) - 2u128.pow(PRECISION_BITS * 2 + 1)).to_bytes_le()
        ).into_iter().map(|x| Constant(F::from_u128(x as u128))).collect();
        let inner_product = self.gate().inner_product(ctx, a_bits, neg_point_bits);
        let is_pos = self.gate().is_zero(ctx, inner_product);
        let is_neg = self.gate().not(ctx, is_pos);

        is_neg
    }

    fn sign(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let pos_one = Constant(F::one());
        // (-1) % m where m = 2^254
        let neg_one = self.gate().sub(ctx, Constant(F::zero()), pos_one);
        let is_neg = self.is_neg(ctx, a);
        let res = self.gate().select(ctx, neg_one, pos_one, is_neg);

        res
    }

    fn clip(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let sign = self.sign(ctx, a);
        let a_abs = self.qabs(ctx, a);
        // assume a < 2^{p+1}
        let a_num_bits = PRECISION_BITS as usize * 2 + 1;
        let m = BigUint::from(2u32).pow(PRECISION_BITS * 2);
        // clipped = a % m
        // TODO (Wentao XIAO) should we just throw panic when overflow?
        let (_, unsigned_cliped) = self.range_gate().div_mod(ctx, a_abs, m, a_num_bits);
        let clipped = self.gate().mul(ctx, sign, unsigned_cliped);

        clipped
    }

    fn qmul(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let num_bits = PRECISION_BITS as usize * 2;
        let ab = self.gate().mul(ctx, a, b);
        let (ab_rescale, _) = self.range_gate().div_mod(
            ctx, Existing(ab), self.quantization_scale.get_lower_128(), num_bits
        );

        ab_rescale
    }

    fn qmod(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let num_bits = PRECISION_BITS as usize * 2;
        let a_rescale = self.gate().mul(ctx, a, Constant(self.quantization_scale));
        let (_, res) = self.range_gate().div_mod_var(
            ctx, a_rescale, b, num_bits, num_bits
        );

        res
    }

    fn qdiv(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        // Because a_rescale \in [0, 2^{2p}) and b \in [0, 2^p)
        let a_num_bits = PRECISION_BITS as usize * 4;
        let b_num_bits = PRECISION_BITS as usize * 2;
        let a_rescale = self.gate().mul(ctx, a, Constant(self.quantization_scale));
        let (res, _) = self.range_gate().div_mod_var(
            ctx, a_rescale, b, a_num_bits, b_num_bits
        );

        res
    }

    fn polynomial<QA>(
        &self,
        ctx: &mut Context<F>,
        x: impl Into<QuantumCell<F>>,
        coef: impl IntoIterator<Item = QA>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField, QA: Into<QuantumCell<F>>
    {
        let x = x.into();
        let mut intermediates = vec![Constant(F::zero())];
        let coef_iter: Vec<QA> = coef.into_iter().collect();
        let last_idx_coef = coef_iter.len() - 1;
        let mut result: AssignedValue<F> = self.qadd(ctx, x, Constant(F::zero()));
        for (idx, c) in coef_iter.into_iter().enumerate() {
            let last_y = *intermediates.get(intermediates.len() - 1).unwrap();
            let y_add = self.qadd(ctx, last_y, c);
            intermediates.push(Existing(y_add));
            if idx < last_idx_coef {
                let y = self.qmul(ctx, x, Existing(y_add));
                intermediates.push(Existing(y));
            } else {
                result = y_add;
            }
        }

        result
    }

    fn check_power_of_two(&self, ctx: &mut Context<F>, pow2_exponent: AssignedValue<F>, exponent: AssignedValue<F>)
    where
        F: BigPrimeField,
    {
        let range_bits = PRECISION_BITS as usize * 2;
        let bits = self.gate().num_to_bits(ctx, pow2_exponent, range_bits);
        let sum_of_bits = self.gate().sum(ctx, bits.clone());
        let sum_of_bits_m1 = self.gate().sub(ctx, sum_of_bits, Constant(F::one()));
        let is_zero = self.gate().is_zero(ctx, sum_of_bits_m1);
        // ensure the bits of pow2_exponent has only one of bit one.
        self.gate().assert_is_const(ctx, &is_zero, &F::one());
        let bit = self.gate().select_from_idx(
            ctx, 
            bits.into_iter().map(|x| Existing(x)), 
            exponent
        );
        let bit_m1 = self.gate().sub(ctx, bit, Constant(F::one()));
        let is_zero_bit_m1 = self.gate().is_zero(ctx, bit_m1);
        // ensures bits[expnent] is exact bit one
        self.gate().assert_is_const(ctx, &is_zero_bit_m1, &F::one());
    }

    fn qexp2(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let a_abs = self.qabs(ctx, a);
        let num_bits = PRECISION_BITS as usize * 2;
        let shift = 2u128.pow(PRECISION_BITS);
        let (int_part, frac_part) = self.range_gate().div_mod(
            ctx, Existing(a_abs), shift, num_bits);
        // int_part will be small as large number leads to overflow.
        let int_part_pow2 = self.gate().pow_of_two()[int_part.value().get_lower_32() as usize];
        // to make use of int_part_pow2 as a Witness, we must first check it's a correct pow2 of int_part.
        let int_part_pow2_witness = self.gate().add(ctx, Witness(int_part_pow2), Constant(F::zero()));
        self.check_power_of_two(ctx, int_part_pow2_witness, int_part);
        let coef: Vec<QuantumCell<F>> = self.generate_exp_poly().iter().map(|x| Constant(*x)).collect();
        let y_frac = self.polynomial(ctx, frac_part, coef);
        let res_pos = self.gate().mul(ctx, Existing(int_part_pow2_witness), Existing(y_frac));

        let one = Constant(u128_to_scalar(shift));
        let res_neg = self.qdiv(ctx, one, res_pos);
        let is_neg = self.is_neg(ctx, a);
        let res = self.gate().select(ctx, res_neg, res_pos, is_neg);

        res
    }
}
