use std::{ops::Sub, fmt::Debug};

use halo2_base::{
    utils::{ScalarField, BigPrimeField}, gates::{GateChip, GateInstructions, RangeChip, range::RangeStrategy, RangeInstructions},
    QuantumCell, Context, AssignedValue
};
use halo2_base::QuantumCell::{Constant, Existing, Witness};
use num_bigint::{BigUint};
use bitvec::{order::Lsb0, vec::BitVec};

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum FixedPointStrategy {
    Vertical, // vanilla implementation with vertical basic gate(s)
}

/// `PRECISION_BITS` indicates the precision of integer and fractional parts.
/// For example, `PRECISION_BITS = 32` indicates this chip implements 32.32 fixed point decimal arithmetics.
/// The valid range of the fixed point decimal is -max_value < x < max_value.
#[derive(Clone, Debug)]
pub struct FixedPointChip<F: ScalarField, const PRECISION_BITS: u32> {
    strategy: FixedPointStrategy,
    pub gate: RangeChip<F>,
    pub quantization_scale: F,
    pub max_value: BigUint,
    pub bn254_max: F,
    pub negative_point: F,
    pub lookup_bits: usize,
}

pub fn u128_to_scalar<F: ScalarField>(x: u128) -> F {
    let x_biguint = BigUint::from(x);
    biguint_to_scalar(x_biguint)
}

pub fn biguint_to_scalar<F: ScalarField>(x: BigUint) -> F {
    let x_biguint = x.to_bytes_le();
    let mut x_bytes_le = [0u8; 64];
    for (idx, val) in x_biguint.iter().enumerate() {
        x_bytes_le[idx] = *val;
    }
    let x_f = F::from_bytes_wide(&x_bytes_le);

    x_f
}

impl<F: ScalarField, const PRECISION_BITS: u32> FixedPointChip<F, PRECISION_BITS> {
    pub fn new(strategy: FixedPointStrategy, lookup_bits: usize) -> Self {
        assert!(PRECISION_BITS <= 63, "support only precision bits <= 63");
        assert!(PRECISION_BITS >= 32, "support only precision bits >= 32");
        let gate = RangeChip::new(
            match strategy {
                FixedPointStrategy::Vertical => RangeStrategy::Vertical,
            },
            lookup_bits
        );
        // Simple uniform symmetric quantization scheme which enforces zero point to be exactly 0
        // to reduce lots of computations.
        // Quantization: x_q = xS where S is `quantization_scale`
        // De-quantization: x = x_q / S
        let quantization_scale = u128_to_scalar(2u128.pow(PRECISION_BITS as u32));
        // Becuase BN254 is cyclic, negative number will be denoted as (-x) % m = m - x where m = 2^254,
        // in this chip, we treat all x > negative_point as a negative numbers.
        let bn254_max = biguint_to_scalar(BigUint::parse_bytes(
            &F::MODULUS[2..].bytes().collect::<Vec<u8>>(), 16).unwrap().sub(1u32));
        // -max_value % m = negative_point
        let negative_point = bn254_max - u128_to_scalar::<F>(2u128.pow(PRECISION_BITS * 2 + 1)) + F::one();
        // min_value < x < max_value
        let max_value = BigUint::from(2u32).pow(PRECISION_BITS * 2);

        Self { strategy, gate, quantization_scale, max_value, bn254_max, negative_point, lookup_bits }
    }

    pub fn default(lookup_bits: usize) -> Self {
        Self::new(FixedPointStrategy::Vertical, lookup_bits)
    }

    pub fn quantization(&self, x: f64) -> F {
        let sign = x.signum();
        let x = x.abs();
        let x_q = (x * self.quantization_scale.get_lower_128() as f64).round() as u128;
        let x_q_biguint = BigUint::from(x_q).to_bytes_le();
        let mut x_q_bytes_le = [0u8; 64];
        for (idx, val) in x_q_biguint.iter().enumerate() {
            x_q_bytes_le[idx] = *val;
        }
        let mut x_q_f = F::from_bytes_wide(&x_q_bytes_le);
        if sign < 0.0 {
            x_q_f = self.bn254_max - x_q_f + F::one();
        }

        x_q_f
    }

    pub fn dequantization(&self, x: F) -> f64 {
        let mut x_mut = x;
        let negative = if x > self.negative_point {
            x_mut = self.bn254_max - x - F::one();
            -1f64
        } else {
            1f64
        };
        let x_u128: u128 = x_mut.get_lower_128();
        let quantization_scale = self.quantization_scale.get_lower_128();
        let x_int = (x_u128 / quantization_scale) as f64;
        let x_frac = (x_u128 % quantization_scale) as f64 / quantization_scale as f64;
        let x_deq = negative * (x_int + x_frac);

        x_deq
    }

    fn generate_exp2_poly(&self) -> Vec<QuantumCell<F>> {
        // generated by remez algorithm, poly degree 12, precision bits: 64.28
        let coef: Vec<F> = [
            3.6240421303547230336183979205877e-11, 4.1284327467833130245549169910389e-10,
            0.0000000071086385644026346316624185550542, 0.00000010172297085296590958930245291448,
            0.0000013215904023658396206789543841996, 0.000015252713316417140696221389106544,
            0.00015403531076657894204857389177279, 0.0013333558131297097698435464957392,
            0.0096181291078409107025643582456283, 0.055504108664804181586140094858174,
            0.24022650695910142332414229540187, 0.69314718055994529934452147700678,
            1.0
        ].into_iter().map(|c| self.quantization(c)).collect();

        coef.iter().map(|x| Constant(*x)).collect()
    }

    fn generate_log_poly(&self) -> Vec<QuantumCell<F>> {
        // generated by lolremez -d 14  -r "2:4" "log2(x)"
        // Estimated max error: 6.4897885416380772e-13
        let coef: Vec<F> = [
            -3.319586265362338e-08, 1.4957235315170112e-06,
            -3.1350053389526744e-05, 0.00040554177582512901,
            -0.0036218342998850703, 0.023663846121538389,
            -0.11691877183255484, 0.44524062371564499,
            -1.3195777548208449, 3.0518128028712077,
            -5.4904626000399528, 7.6298580090181591,
            -8.1653313719804235, 7.1389971101896279,
            -3.1937385492842112
        ].into_iter().map(|c| self.quantization(c)).collect();

        coef.iter().map(|x| Constant(*x)).collect()
    }

    fn generate_sin_poly(&self) -> Vec<QuantumCell<F>> {
        // generated by lolremez -d 14  -r "0:pi" "sin(x)"
        // Estimated max error: 1.9323057584419826e-15
        let coef: Vec<F> = [
            -1.1008071636607462e-11, 2.4208013888629323e-10,
            -3.8584805817996712e-10, -2.3786993104309845e-08,
            -2.9795813710683115e-09, 2.7608543130047009e-06,
            -6.4467066994122565e-09, -0.00019840680551418068,
            -3.839555844512214e-09, 0.0083333350601673614,
            -5.0943769725466814e-10, -0.16666666657583049,
            -8.5029878414113731e-12, 1.0000000000003146,
            -1.9323057584419828e-15
        ].into_iter().map(|c| self.quantization(c)).collect();

        coef.iter().map(|x| Constant(*x)).collect()
    }
}

pub trait FixedPointInstructions<F: ScalarField, const PRECISION_BITS: u32> {
    /// Fixed point decimal and its arithmetic functions.
    /// [ref] https://github.com/XMunkki/FixPointCS/blob/c701f57c3cfe6478d1f6fd7578ae040c59386b3d/Cpp/Fixed64.h
    /// [ref] https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol
    ///
    type Gate: GateInstructions<F>;
    type RangeGate: RangeInstructions<F>;

    fn gate(&self) -> &Self::Gate;
    fn range_gate(&self) -> &Self::RangeGate;
    fn strategy(&self) -> FixedPointStrategy;

    fn qabs(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn is_neg(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn sign(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn cond_neg(
        &self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>, is_neg: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    /// clip the value to ensure it's in the valid range: (-2^p, 2^p), i.e., simulate overflow
    /// Warning: assuome a < 2^{p+1},This may fail silently if a is too large
    /// (e.g., mul of two large number leads to 2^{2p}).
    fn clip(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn polynomial<QA>(
        &self,
        ctx: &mut Context<F>,
        x: impl Into<QuantumCell<F>>,
        coef: impl IntoIterator<Item = QA>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField, QA: Into<QuantumCell<F>> + Debug + Copy;

    fn bit_xor(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = self.gate().add(ctx, Constant(F::zero()), a.into());
        let b = self.gate().add(ctx, Constant(F::zero()), b.into());
        self.gate().assert_bit(ctx, a);
        self.gate().assert_bit(ctx, b);
        let ab = self.gate().add(ctx, a, b);
        let one = self.gate().add(ctx, Constant(F::one()), Constant(F::zero()));
        let xor = self.gate().is_equal(ctx, ab, one);

        xor
    }

    fn qsum<Q>(&self, ctx: &mut Context<F>, a: impl IntoIterator<Item = Q>) -> AssignedValue<F>
    where
        Q: Into<QuantumCell<F>>,
    {
        self.gate().sum(ctx, a)
    }

    fn neg(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        self.gate().neg(ctx, a)
    }

    fn qadd(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn qsub(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;
    
    fn qmul(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;
    
    fn qdiv(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;
    
    fn inner_product<QA>(
        &self,
        ctx: &mut Context<F>,
        a: impl IntoIterator<Item = QA>,
        b: impl IntoIterator<Item = QA>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField, QA: Into<QuantumCell<F>> + Copy;

    fn qmod(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    /// exp2
    fn qexp2(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    /// log
    fn qlog2(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;
 
    /// sin
    fn qsin(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField;

    fn check_power_of_two(&self, ctx: &mut Context<F>, pow2_exponent: AssignedValue<F>, exponent: AssignedValue<F>)
    where
        F: BigPrimeField;
}

impl<F: ScalarField, const PRECISION_BITS: u32> FixedPointInstructions<F, PRECISION_BITS> for FixedPointChip<F, PRECISION_BITS> {
    type Gate = GateChip<F>;
    type RangeGate = RangeChip<F>;

    fn range_gate(&self) -> &Self::RangeGate {
        &self.gate
    }

    fn gate(&self) -> &Self::Gate {
        &self.gate.gate()
    }

    fn strategy(&self) -> FixedPointStrategy {
        self.strategy
    }

    fn qadd(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        self.gate().add(ctx, a, b)
    }

    fn qsub(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        self.gate().sub(ctx, a, b)
    }

    fn qabs(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let a_reverse = self.gate().neg(ctx, a);
        let is_neg = self.is_neg(ctx, a);
        let a_abs = self.gate().select(ctx, a_reverse, a, is_neg);

        a_abs
    }

    fn is_neg(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let a_assigned = self.gate().add(ctx, a, Constant(F::zero()));
        let a_bits = self.gate().num_to_bits(ctx, a_assigned, 254);
        // for example, PRECISION_BITS = 63, then neg_point_bits = 1..10..0 where has 127 ones and 254 - 127 zeros
        let neg_point_bits: Vec<QuantumCell<F>> = BitVec::<_, Lsb0>::from_vec(
            (BigUint::from(2u32).pow(254u32) - 2u128.pow(PRECISION_BITS * 2 + 1)).to_bytes_le()
        ).into_iter().map(|x| Constant(F::from_u128(x as u128))).collect();
        let inner_product = self.gate().inner_product(ctx, a_bits, neg_point_bits);
        // >= 0
        let is_pos = self.gate().is_zero(ctx, inner_product);
        let is_neg = self.gate().not(ctx, is_pos);

        is_neg
    }

    fn cond_neg(
        &self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>, is_neg: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let neg_a = self.gate().neg(ctx, a);
        let is_neg_assigned = self.gate().add(ctx, is_neg, Constant(F::zero()));
        // self.gate().assert_bit(ctx, is_neg_assigned);
        let res = self.gate().select(ctx, neg_a, a, is_neg_assigned);

        res
    }

    fn sign(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let pos_one = Constant(F::one());
        // (-1) % m where m = 2^254
        let neg_one = self.gate().neg(ctx, pos_one);
        let is_neg = self.is_neg(ctx, a);
        let res = self.gate().select(ctx, neg_one, pos_one, is_neg);

        res
    }

    fn clip(&self, ctx: &mut Context<F>, a: impl Into<QuantumCell<F>>) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let sign = self.is_neg(ctx, a);
        let a_abs = self.qabs(ctx, a);
        let a_num_bits = 254;
        let m = self.max_value.clone();
        // clipped = a % m
        // TODO (Wentao XIAO) should we just throw panic when overflow?
        let (_, unsigned_cliped) = self.range_gate().div_mod(ctx, a_abs, m, a_num_bits);
        let clipped = self.cond_neg(ctx, unsigned_cliped, sign);

        clipped
    }

    fn qmul(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let b = b.into();
        // note that a, b < 2^{2p}, so ab < 2^{4p}, if the num_bits is less than this, the div_mod()
        // will leads to constraint not satisfied with outside any region
        let num_bits = PRECISION_BITS as usize * 4;
        let a_sign = self.is_neg(ctx, a);
        let b_sign = self.is_neg(ctx, b);
        let a_abs = self.qabs(ctx, a);
        let b_abs = self.qabs(ctx, b);
        let ab_abs = self.gate().mul(ctx, a_abs, b_abs);
        let ab_sign = self.bit_xor(ctx, a_sign, b_sign);
        let (ab_rescale, _) = self.range_gate().div_mod(
            ctx, ab_abs, self.quantization_scale.get_lower_128(), num_bits
        );
        let res = self.cond_neg(ctx, ab_rescale, ab_sign);

        res
    }

    fn qmod(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        // b must be positive
        let a = a.into();
        let b = b.into();
        let a_sign = self.is_neg(ctx, a);
        let b_sign = self.is_neg(ctx, b);
        self.gate().assert_is_const(ctx, &b_sign, &F::zero());
        let a_abs = self.qabs(ctx, a);
        let a_num_bits = PRECISION_BITS as usize * 4;
        let b_num_bits = PRECISION_BITS as usize * 2;
        let (_, res_abs) = self.range_gate().div_mod_var(
            ctx, a_abs, b, a_num_bits, b_num_bits
        );
        let res_abs_comp = self.gate().sub(ctx, b, res_abs);
        let res = self.gate().select(ctx, res_abs_comp, res_abs, a_sign);

        res
    }

    fn qdiv(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let b = b.into();
        let a_sign = self.is_neg(ctx, a);
        let b_sign = self.is_neg(ctx, b);
        let a_abs = self.qabs(ctx, a);
        let b_abs = self.qabs(ctx, b);
        // Because a_rescale \in [0, 2^{4p}) and b \in [0, 2^p)
        let a_num_bits = PRECISION_BITS as usize * 4;
        let b_num_bits = PRECISION_BITS as usize * 2;
        let a_rescale = self.gate().mul(ctx, a_abs, Constant(self.quantization_scale));
        let (res_abs, _) = self.range_gate().div_mod_var(
            ctx, a_rescale, b_abs, a_num_bits, b_num_bits
        );
        let ab_sign = self.bit_xor(ctx, a_sign, b_sign);
        let res = self.cond_neg(ctx, res_abs, ab_sign);

        res
    }

    fn polynomial<QA>(
        &self,
        ctx: &mut Context<F>,
        x: impl Into<QuantumCell<F>>,
        coef: impl IntoIterator<Item = QA>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField, QA: Into<QuantumCell<F>> + Debug + Copy
    {
        let x = x.into();
        let mut intermediates = vec![Constant(F::zero())];
        let coef_iter: Vec<QA> = coef.into_iter().collect();
        let last_idx_coef = coef_iter.len() - 1;
        let mut result: AssignedValue<F> = self.qadd(ctx, x, Constant(F::zero()));
        for (idx, c) in coef_iter.into_iter().enumerate() {
            let last_y = *intermediates.get(intermediates.len() - 1).unwrap();
            let y_add = self.qadd(ctx, last_y, c);
            intermediates.push(Existing(y_add));
            if idx < last_idx_coef {
                let y = self.qmul(ctx, x, Existing(y_add));
                intermediates.push(Existing(y));
            } else {
                result = y_add;
            }
        }

        result
    }

    fn check_power_of_two(&self, ctx: &mut Context<F>, pow2_exponent: AssignedValue<F>, exponent: AssignedValue<F>)
    where
        F: BigPrimeField,
    {
        let range_bits = PRECISION_BITS as usize * 2;
        let bits = self.gate().num_to_bits(ctx, pow2_exponent, range_bits);
        let sum_of_bits = self.gate().sum(ctx, bits.clone());
        let sum_of_bits_m1 = self.gate().sub(ctx, sum_of_bits, Constant(F::one()));
        let is_zero = self.gate().is_zero(ctx, sum_of_bits_m1);
        // ensure the bits of pow2_exponent has only one of bit one.
        self.gate().assert_is_const(ctx, &is_zero, &F::one());
        let bit = self.gate().select_from_idx(
            ctx, 
            bits.into_iter().map(|x| Existing(x)), 
            exponent
        );
        let bit_m1 = self.gate().sub(ctx, bit, Constant(F::one()));
        let is_zero_bit_m1 = self.gate().is_zero(ctx, bit_m1);
        // ensures bits[expnent] is exact bit one
        self.gate().assert_is_const(ctx, &is_zero_bit_m1, &F::one());
    }

    fn qexp2(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let a_abs = self.qabs(ctx, a);
        let num_bits = PRECISION_BITS as usize * 2;
        let shift = 2u128.pow(PRECISION_BITS);
        let (int_part, frac_part) = self.range_gate().div_mod(
            ctx, Existing(a_abs), shift, num_bits);
        // int_part must be small as large number leads to overflow.
        let int_part_pow2 = self.gate().pow_of_two()[int_part.value().get_lower_32() as usize];
        // to make use of int_part_pow2 as a Witness, we must first check it's a correct pow2 of int_part.
        let int_part_pow2_witness = self.gate().add(ctx, Witness(int_part_pow2), Constant(F::zero()));
        self.check_power_of_two(ctx, int_part_pow2_witness, int_part);
        let coef = self.generate_exp2_poly();
        let y_frac = self.polynomial(ctx, frac_part, coef);
        let res_pos = self.gate().mul(ctx, Existing(int_part_pow2_witness), Existing(y_frac));

        let one = Constant(u128_to_scalar(shift));
        let res_neg = self.qdiv(ctx, one, res_pos);
        let is_neg = self.is_neg(ctx, a);
        let res = self.gate().select(ctx, res_neg, res_pos, is_neg);

        res
    }

    fn qlog2(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let a_assigned = self.gate().add(ctx, a, Constant(F::zero()));
        let is_neg = self.is_neg(ctx, a);
        let is_zero = self.gate().is_zero(ctx, a_assigned);
        let is_invalid = self.gate().or(ctx, is_neg, is_zero);
        self.gate().assert_is_const(ctx, &is_invalid, &F::zero());
        let num_bits = (PRECISION_BITS * 2) as usize;
        let num_digits = a_assigned.value()
            .to_repr()
            .as_ref()
            .iter()
            .flat_map(|byte| (0..8u32).map(|i| (*byte as u64 >> i) & 1))
            .enumerate()
            .fold(1u64, |acc, (idx, val)| {
                if val == 1u64 {
                    idx as u64
                } else {
                    acc
                }
            });
        let pow1 = self.gate().pow_of_two()[num_digits as usize];
        let pow1_witness = self.gate().add(ctx, Witness(pow1), Constant(F::zero()));
        let exp1 = self.gate().add(ctx, Witness(F::from(num_digits)), Constant(F::zero()));
        self.check_power_of_two(ctx, pow1_witness, exp1);
        let pow2_witness = self.gate().mul(ctx, pow1_witness, Constant(F::from(2)));
        let exp2 = self.gate().add(ctx, exp1, Constant(F::one()));
        self.check_power_of_two(ctx, pow2_witness, exp2);
        // pow1 <= a < pow2, pow1 = 2^n, pow2 = 2^{n+1}
        let a_lt_pow2 = self.range_gate().is_less_than(ctx, a, pow2_witness, num_bits);
        let a_gt_pow1 = self.range_gate().is_less_than(ctx, pow1_witness, a, num_bits);
        let a_eq_pow1 = self.gate().is_equal(ctx, a, pow1_witness);
        let a_ge_pow1 = self.gate().or(ctx, a_eq_pow1, a_gt_pow1);
        let a_bound = self.gate().and(ctx, a_lt_pow2, a_ge_pow1);
        self.gate().assert_is_const(ctx, &a_bound, &F::one());

        // shift a to ensure a = 2^m * k, m \in Z, 2^{1} <= k < 2^{2}
        let shift = self.gate().sub(
            ctx, Constant(F::from(PRECISION_BITS as u64 + 2)), exp2);
        let is_shift_neg = self.is_neg(ctx, shift);
        let shift_abs = self.qabs(ctx, shift);
        let shift_pow2 = self.gate().pow_of_two()[shift_abs.value().get_lower_32() as usize];
        let shift_pow2_witness = self.gate().add(ctx, Witness(shift_pow2), Constant(F::zero()));
        self.check_power_of_two(ctx, shift_pow2_witness, shift_abs);
        let a_ls = self.gate().mul(ctx, a, shift_pow2_witness);
        let (a_rs, _) = self.range_gate().div_mod_var(
            ctx, a, shift_pow2_witness, num_bits, PRECISION_BITS as usize + 1);
        let a_norm = self.gate().select(ctx, a_rs, a_ls, is_shift_neg);

        let coef = self.generate_log_poly();
        let log_a_norm = self.polynomial(ctx, a_norm, coef);

        let log_shift = self.gate().neg(ctx, shift);
        let log_shift_q = self.gate().mul(ctx, log_shift, Constant(self.quantization_scale));
        let res = self.gate().add(ctx, log_a_norm, log_shift_q);

        res
    }

    fn bit_xor(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>,
        b: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = self.gate().add(ctx, Constant(<F>::zero()), a.into());
        let b = self.gate().add(ctx, Constant(<F>::zero()), b.into());
        self.gate().assert_bit(ctx, a);
        self.gate().assert_bit(ctx, b);
        let ab = self.gate().add(ctx, a, b);
        let one = self.gate().add(ctx, Constant(<F>::one()), Constant(<F>::zero()));
        let xor = self.gate().is_equal(ctx, ab, one);

        xor
    }

    fn qsin(
        &self,
        ctx: &mut Context<F>,
        a: impl Into<QuantumCell<F>>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField
    {
        let a = a.into();
        let a_abs = self.qabs(ctx, a);
        let a_sign = self.is_neg(ctx, a);
        let pi_2 = Constant(self.quantization(std::f64::consts::PI * 2.0));
        // |a| % 2pi
        let a_mod = self.qmod(ctx, a_abs, pi_2);
        let pi = Constant(self.quantization(std::f64::consts::PI));
        // (|a| % 2pi) - pi
        let a_mpi = self.qsub(ctx, a_mod, pi);
        let is_neg_a_mpi = self.is_neg(ctx, a_mpi);
        let coef1 = self.generate_sin_poly();
        let sin_a_mod = self.polynomial(ctx, a_mod, coef1);
        let coef2 = self.generate_sin_poly();
        // -sin(a-pi) for pi <= a < 2pi
        let sin_a_mpi_rev = self.polynomial(ctx, a_mpi, coef2);
        let sin_a_mpi = self.neg(ctx, sin_a_mpi_rev);
        let sin_a_abs = self.gate().select(ctx, sin_a_mod, sin_a_mpi, is_neg_a_mpi);
        let sin_a = self.cond_neg(ctx, sin_a_abs, a_sign);

        sin_a
    }

    fn inner_product<QA>(
        &self,
        ctx: &mut Context<F>,
        a: impl IntoIterator<Item = QA>,
        b: impl IntoIterator<Item = QA>
    ) -> AssignedValue<F>
    where 
        F: BigPrimeField, QA: Into<QuantumCell<F>> + Copy
    {
        let a: Vec<QA> = a.into_iter().collect();
        let b: Vec<QA> = b.into_iter().collect();
        assert!(a.len() == b.len());
        let mut res = self.qadd(ctx, Constant(F::zero()), Constant(F::zero()));
        for (ai, bi) in a.iter().zip(b.iter()).into_iter() {
            let ai_bi = self.qmul(ctx, *ai, *bi);
            res = self.qadd(ctx, res, ai_bi);
        }

        res
    }
}
